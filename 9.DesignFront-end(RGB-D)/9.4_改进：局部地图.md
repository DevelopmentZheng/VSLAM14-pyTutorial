&emsp;
# 9.4 改进：局部地图

本节，我们将 VO 匹配到的特征点放到地图中，并将当前帧与地图点进行匹配，计算位姿。这种做法与之前的差异可见图 9-6 。

<div align="center">
    <image src="./imgs/9.4-1.png" width = 600>
</div>
&emsp;

在两两帧间比较时，我们只计算参考帧与当前帧之间的特征匹配和运动关系，在计算之后把当前帧设为新的参考帧。而在使用地图的 VO 中，每个帧为地图贡献一些信息，比方说添加新的特征点或更新旧特征点的位置估计。地图中的特征点位置往往是使用世界坐标的。因此，当前帧到来时，我们求它和地图之间的特征匹配与运动关系，即直接计算了 Tcw。

这样做的好处是，我们能够维护一个不断更新的地图。只要地图是正确的，即使中间某帧出了差错，仍有希望求出之后那些帧的正确位置。请注意，我们现在还没有详细地讨论 SLAM 的建图问题，所以这里的地图仅是一个临时性的概念，指的是把各帧特征点缓存到一个地方，构成了特征点的集合，我们称它为地图。

地图又可以分为 `局部（Local）地图` 和 `全局（Global）地图` 两种，由于用途不同，往往分开讨论。顾名思义，局部地图描述了附近的特征点信息——我们只保留离相机当前位置较近的特征点，而把远的或视野外的特征点丢掉。这些特征点是用来和当前帧匹配来求相机位置的，所以我们希望它能够做的比较快。另一方面，全局地图则记录了从 SLAM 运行以来的所有特征点。它显然规模要大一些，主要用来表达整个环境，但是直接在全局地图
上定位，对计算机的负担就太大了。它主要用于回环检测和地图表达。

在视觉里程计中，我们更关心可以直接用于定位的局部地图（如果决心要用地图的话）。所以本讲我们来维护一个局部地图。随着相机运动，我们往地图里添加新的特征点，并去掉之前，我们仍然要提醒读者：是否使用地图取决你对精度——效率这个矛盾的把握。我们完全可以出于效率的考量，使用两两无结构式的 VO；也可以为了更好的精度，构建局部地图乃至考虑地图的优化。

局部地图的一件麻烦事是维护它的规模。为了保证实时性，我们需要保证地图规模不至于太大（否则匹配会消耗大量的时间）。此外，单个帧与地图的特征匹配存在着一些加速手段，但由于它们技术上比较复杂，我们的例程中就不给出了。

现在，来实现地图点类吧。我们稍加完善之前没有用到的 MapPoint 类，主要是它的构造函数和生成函数。

主要的修改在 VisualOdometry 类上。由于工作流程的改变，我们修改了它的几个主要函数，例如每次循环中要对地图进行增删、统计每个地图点被观测到的次数等等。这些事情是比较琐碎的，所以我们还是建议读者仔细看看 github 提供的源代码。重点观察以下几项：

1. 在提取第一帧的特征点之后，将第一帧的所有特征点全部放入地图中：

2. 后续的帧中，使用 OptimizeMap 函数对地图进行优化。包括删除不在视野内的点，在匹配数量减少时添加新点等等。

    我们刻意留空了一些地方，请感兴趣的读者自行完成。例如，你可以使用三角化来更新特征点的世界坐标，或者考虑更好地动态管理地图规模的策略。这些问题都是开放性的。

3. 特征匹配代码。匹配之前，我们从地图中拿出一些候选点（出现在视野内的点），然后将它们与当前帧的特征描述子进行匹配。


除了现有的地图之外，我们还引入了“关键帧”（Key-frame）的概念。关键帧在许多视觉 SLAM 中都会用到，不过这个概念主要是给后端用的，所以我们下几讲再讨论对关键帧的详细处理。在实践中，我们肯定不希望对每个图像都做详细的优化和回环检测，那样毕竟太耗费资源。至少相机搁在原地不动时，我们不希望整个模型（地图也好、轨迹也好）变得越来越大。因此，后端优化的主要对象就是关键帧。

关键帧是相机运动过程当中某几个特殊的帧，这里“特殊”的意义是可以由我们自己指定的。常见的做法时，每当相机运动经过一定间隔，就取一个新的关键帧并保存起来。

这些关键帧的位姿将被仔细优化，而位于两个关键帧之间的那些东西，除了对地图贡献一些地图点外，就被理所当然地忽略掉了。

本节的实现也会提取一些关键帧，为后端的优化作一些数据上的准备。现在，读者可以编译这个工程，看看它的运行结果。本节的例程会把局部地图的点投影到图像平面并显示出来。如果位姿估计正确的话，它们看起来应该像是固定在空间中一样。反之，如果你感觉到某个特征点不自然地运动，那可能是相机位姿估计不够准确，或特征点的位置不够准确。

我们在 0.4 版没有提供对地图的优化，建议读者自行尝试一下。用到的原理主要是最小二乘和三角化，在前两节都已经介绍过，不会太困难。
